# Design Document

## Intended Usage
```
nwd <project-name> [options]
```

## Intended Options
```
-l <language>, --language=<language>
	Specifies the language to use for the project.
	Defaults to C.

-r <path/to/remote>, --remote=<path/to/remote>
	Specifies a path to the remote git repository to set as origin.
	No default.

--license=<license>
	Copy over a license file if specified.
	Licenses include GPL-3, MIT, etc.
```

## Intended Behaviour
Creates a new directory according to the language given.
Should separate directories for source files, object/compiled files and executables.

Should generate a directory tree suitable for each language, each language can have some customisation but after the base tree is generated.
(eg Fortran-90 doesn't have header files so doesn't need an `include/` directory.

Copies the relevant files from a directory where the script is located.
Should have the bare-bones for the project to be able to compile right away with the provided makefile.

Easily expandable to add new languages. Do this via separate source directories and custom scripts for each language. eg
```
nwd-2/
├── dirs.txt
├── docs
│   ├── DESIGN.md
│   ├── MANUAL.md
│   ├── README.md
│   └── TODO.md
├── languages
│   ├── c
│   │   ├── makefile
│   │   └── specifics.sh
│   ├── cpp
│   │   ├── makefile
│   │   └── specifics.sh
│   └── f90
│       ├── makefile
│       └── specifics.sh
├── licenses
│   ├── GPL-3
│   └── MIT
└── nwd
```
Language extensions can be easily written with a script file by end users and the source `nwd` script should not need to be edited.
Automatically detect languages by `ls languages/` but this -creates the issue of not having aliases.-
Aliases can be created by symlinking directories inside the languages directory.

However, keep a naming convention that everything stays as short, alphanumeric and lower-case as possible.

Have the core program in one script file, then pass off to a language-specific script once the basics are done.
User can tweak each directory structure as they please via external directory files. ie read directory tree from file, then a separate one for each langauge.

Create a README, design doc, manual and license. First three in markdown.

## Directory Structure

### Compiled Languages
```
project/
├── bin/
│   ├── libs/
│   ├── logs/
│   ├── metadata/
│   ├── objects/
│   ├── so/
│   └── Makefile
├── include/
│   ├── sub1/
│   ├── sub2/
│   └── project.h
└── src/
    ├── sub1/
    ├── sub2/
    └── project.c
```
- `project/` - The main directory for each project.
- `bin/` - The directory for all binary files and compilation to happen.
- `libs/` - Where external libraries used to compile and run the program are stored.
- `logs/` - Where all build logs are stored. Logs files should contain timestamped make outputs, relevant environment variables etc.
- `metadata/` - Directory to keep all metadata about the binary. Things like build number, build date etc.
- `objects/` - Where all compiled but not linked object files are stored.
- `so/` - Where all library files generated by the project are supposed to be stored.
- `Makefile` - The GNU makefile for the project.
- `include/` - Directory for all header and include files used by the project.
- `project.h` - The barebones header file for the executable to include.
- `src/` - Directory for all user source files to be stored.
- `project.c` - The barebones source file and entry point for the program.

Each sub-directory in `src/` should correspond to the equivalent in `include`.
Then the makefile should treat each sub-directory as an isolated bit of code (unless it requires other headers/libraries).
When compiled, each subdirectory should produce only one `.so` or `.a` file in `bin/so/` to be linked against the program.
The name of the library should be the subdirectory name with the prefix `lib`
For example, the subdirectory `sub1/` should produce the shared object `libsub1.so` 

Only source files directly in `src/` should be compiled to generate the executable.
The rest should either contribute to a library or not be part of the executable.

### Interpreted Languages
Nothing yet.
Maybe try adding Python later.

## Language Specifics
### Init files
Init files will necessatily be language-specific.
Sometimes they will need to contain the project name in them.
In this case, use `sed` to replace a pattern with the project name.

For example, probably worst-case scenario, C header files.
Template looks like
```C
#ifndef TEMPLATE_H
#define TEMPLATE_H

#endif
```

When given `$project_name` variable, will need to sanitise the name.
Convert all non-alphanumeric characters to `_` then convert alphabetic characters to upper case.

Once done, replace `TEMPLATE` with `$project_name_sanitised` and copy over.

### specifics.sh
`specifics.sh` should be a shell script that is specific to each language.
It deals with editing the directory tree, eg
```
rm include/
mkdir data/
mkdir outdata/
```

and it should also deal with creating/editing and copying over the init files for each language.
If path variables need to be set, then this is where to set them as well.

### Makefile
The makefile should be able to:
- Compile a single executable.
- Compile a single shared object/static object file.
- Compile a single executable + sub-modules/libraries.
- Compile multiple sub-modules/libraries with no executable.
- Save a build number/date for each final binary produced. Updated every link.
- Create a log file of what commands were run at each timestamp as well as print to screen.

