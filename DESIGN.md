# Design Document

## Intended Usage
```
nwd <project-name> [options]
```

## Intended Options
```
-l <language>, --language=<language>
	Specifies the language to use for the project.
	Defaults to C.

-r <path/to/remote>, --remote=<path/to/remote>
	Specifies a path to the remote git repository to set as origin.
	No default.

--license=<license>
	Copy over a license file if specified.
	Licenses include GPL-3, MIT, etc.
```

## Intended Behaviour
Creates a new directory according to the language given.
Should separate directories for source files, object/compiled files and executables.

Should generate a directory tree suitable for each language, each language can have some customisation but after the base tree is generated.
(eg Fortran-90 doesn't have header files so doesn't need an `include/` directory.

Copies the relevant files from a directory where the script is located.
Should have the bare-bones for the project to be able to compile right away with the provided makefile.

Easily expandable to add new languages. Do this via separate source directories and custom scripts for each language. eg
```
nwd-2/
├── c/
│   ├── specifics.sh
│   ├── dirtweaks.txt
│   └── Makefile
├── cpp/
│   ├── specifics.sh
│   ├── dirtweaks.txt
│   └── Makefile
├── f90/
│   ├── specifics.sh
│   ├── dirtweaks.txt
│   └── Makefile
├── licenses/
│   ├── GPL-3
│   └── MIT
├── docs/
│   ├── README.md
│   ├── DESIGN.md
│   └── MANUAL.md
├── dirs.txt
└── nwd

```

Have the core program in one script file, then pass off to a language-specific script once the basics are done.
User can tweak each directory structure as they please via external directory files. ie read directory tree from file, then a separate one for each langauge.

Create a README, design doc, manual and license. First three in markdown.

## Directory Structure

### Compiled Languages
```
project/
├── bin/
│   ├── libs/
│   ├── logs/
│   ├── metadata/
│   ├── objects/
│   ├── so/
│   └── Makefile
├── include/
│   ├── lib1/
│   ├── lib2/
│   └── project.h
└── src/
    ├── lib1/
    ├── lib2/
    └── project.c
```
- `project/` - The main directory for each project.
- `bin/` - The directory for all binary files and compilation to happen.
- `libs/` - Where external libraries used to compile and run the program are stored.
- `logs/` - Where all build logs are stored. Logs files should contain timestamped make outputs, relevant environment variables etc.
- `metadata/` - Directory to keep all metadata about the binary. Things like build number, build date etc.
- `objects/` - Where all compiled but not linked object files are stored.
- `so/` - Where all library files generated by the project are supposed to be stored.
- `Makefile` - The GNU makefile for the project.
- `include/` - Directory for all header and include files used by the project.
- `project.h` - The barebones header file for the executable to include.
- `src/` - Directory for all user source files to be stored.
- `project.c` - The barebones source file and entry point for the program.

Each sub-directory in `src/` should correspond to the equivalent in `include`.
Then the makefile should treat each sub-directory as an isolated bit of code (unless it requires other headers/libraries).
When compiled, each subdirectory should produce only one `.so` or `.a` file in `bin/so/` to be linked against the program.

Only source files directly in `src/` should be compiled to generate the executable.
The rest should either contribute to a library or not be part of the executable.

### Interpreted Languages
Nothing yet.
Maybe try adding Python later.

## Makefile
The makefile should be able to:
- Compile a single executable.
- Compile a single shared object/static object file.
- Compile a single executable + sub-modules/libraries.
- Compile multiple sub-modules/libraries with no executable.
- Save a build number/date for each final binary produced. Updated every link.
- Create a log file of what commands were run at each timestamp as well as print to screen.

## Language Specifics
### Init files
Init files will necessatily be language-specific.
Sometimes they will need to contain the project name in them.
In this case, use `sed` to replace a pattern with the project name.

For example, probably worst-case scenario, C header files.
Template looks like
```C
#ifndef TEMPLATE_H
#define TEMPLATE_H

#endif
```

When given `$project_name` variable, will need to sanitise the name.
Convert all non-alphanumeric characters to `_` then convert alphabetic characters to upper case.

Once done, replace `TEMPLATE` with `$project_name_sanitised` and copy over.

### dirtweaks.txt
`dirtweaks.txt` should be a pseudo-language and should add/remove files or directories as intended.

For example, Fortran-90 could look like this
```
- include/
+ data/
+ outdata/
```

With first column being what to do, second column being what to apply to.
- `+` Create new file/directory.
- `-` Remove file/directory.
- `r` Rename file/directory.

## TODO List
- Handle main input
- Error check and sanitise main input
- Handle input flags + error check (don't need to execute any specific code, just separate and run accorgdingly)
- Generate basic directory structure. Put structure in external file so users can edit as they like.
- Handle C language
- Implement basic makefile.
- Set language based on the `-l` flag. Default to C. Have a switch-case block to take in different versions of the same name, eg C++, c++, Cpp, cpp... 
- Set git remote repository. Try to clone first? If failed, exit, else carry on as normal.
- Handle C++ language
- Handle Fortran-90 language
- Update more of the makefile.
- Handle recognition and generation of license.
- Handle readme, manual and design doc. Readme and manual should have project name as title. Design doc is static.
